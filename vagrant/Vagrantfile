# -*- mode: ruby -*-
# vi: set ft=ruby :

ENV['project_root'] = project_root = File.expand_path(File.dirname(__FILE__))
ENV['valkyrie_root'] = valkyrie_root = "#{project_root}/.valkyrie/valkyrie/vagrant"

semaphore = "#{project_root}/.valkyrie/cache/first_run_complete"

Vagrant.configure(2) do |config|
  require "#{valkyrie_root}/load_config"
  conf = load_config()
  conf['project_root'] = project_root

  # Since we change the SSH user, we need to first install a public key. This
  # is done on the initial provisioning, which needs to run as the 'vagrant'
  # user. So, we switch based on the presence of a semaphore file, which we
  # create on provisioning, and remove after destroy.
  first_run = !File.file?(semaphore)

  config.trigger.after [:destroy] do
    # Remove semaphore file
    system "rm #{semaphore} > /dev/null 2>&1; echo '==> Removed semaphore file: #{semaphore}'"
  end

  # Silence annoying and spurious warnings
  config.ssh.shell = 'bash -c "BASH_ENV=/etc/profile exec bash"'

  config.ssh.forward_agent = true

  config.vm.define 'default' do |vm1|

    require "#{valkyrie_root}/vagrant-bindfs"
    if Vagrant.has_plugin? 'vagrant-bindfs'
      configure_vagrant_bindfs(config, conf)
    else
      install_vagrant_bindfs(conf)
    end

    require "#{valkyrie_root}/drush_aliases"
    drush_aliases(config, conf)

    require "#{valkyrie_root}/vagrant-dns"
    if Vagrant.has_plugin? 'vagrant-dns'
      configure_vagrant_dns(config, conf)
    else
      install_vagrant_dns(conf)
      avahi_fallback(config, conf)
    end

    vm1.vm.network 'private_network', ip: conf['ip']
    vm1.vm.box = conf['vm_box']
    vm1.vm.provider 'virtualbox' do |vbox|
      vbox.memory = conf['vm_memory']
    end


    # Mount /vagrant via NFS (for performance, since we're now running code for
    # the Valkyrie Drush extension directly from there.
    config.vm.synced_folder '.', '/vagrant', type: 'nfs'
    config.bindfs.bind_folder "/vagrant", "/vagrant"

    if first_run
      vm1.vm.provision 'file',
        source: '~/.ssh/id_rsa.pub',
        destination: '/vagrant/.valkyrie/ssh/authorized_keys'
    else
      # SSH as the 'aegir' user
      config.ssh.username = 'aegir'
      config.ssh.private_key_path = '~/.ssh/id_rsa'

      if Vagrant.has_plugin? 'vagrant-bindfs'
        config.bindfs.default_options :perms => nil,
          :force_user => "aegir",
          :force_group => "www-data",
          :o => "nonempty",
          :'chown-ignore' => true,
          :'chmod-ignore' => true,
          :'chgrp-ignore' => true
        conf['bindfs_paths'].each do |guest_path, host_path|
          config.vm.synced_folder host_path, "/bindfs/#{host_path}", type: "nfs"
          config.bindfs.bind_folder "/bindfs/#{host_path}", guest_path
        end
      end

      # Re-generate Aegir site's Drush aliases, now that bindfs has mounted the
      # aliases dir.
      vm1.vm.provision 'shell',
        inline: 'sudo -H -u aegir drush @hm provision-verify 2&>1 /dev/null'

      # Copy in some user-specific files to make the environment more familiar
      conf['dot_files'].each do |dot_file|
        real_dotfile = ENV['HOME']+'/'+dot_file
        if File.file?(real_dotfile)
          vm1.vm.provision 'file', source: real_dotfile,
            destination: "/var/aegir/#{dot_file}"
        end
      end
    end

    facter = { 'fqdn' => config.vm.hostname }
    # Facter cannot determine the domain under vagrant-dns, so we set it
    # directly.
    if Vagrant.has_plugin? 'vagrant-dns'
      facter['domain'] = conf['tld']
    else
      facter['domain'] = 'local'
    end

    vm1.vm.provision 'puppet',
      module_path: "#{valkyrie_root}/puppet/modules",
      manifests_path: "#{valkyrie_root}/puppet/manifests",
      facter: facter

  end
end
